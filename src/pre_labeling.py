import openai
import json
import os
from tqdm import tqdm
import sys
import concurrent.futures

api_key = os.environ.get("BOTHUB_API_KEY")

if not api_key:
    raise ValueError(
        "Не найдена переменная окружения BOTHUB_API_KEY. Убедитесь, что она установлена."
    )

client = openai.OpenAI(api_key=api_key, base_url="https://bothub.chat/api/v2/openai/v1")

input_filename = "data/chgk_for_label_studio_combined_shuffled.json"
MAX_TASKS_TO_PROCESS = 1000
MAX_WORKERS = 10
FIRST_TASK = 0


try:
    with open(input_filename, "r", encoding="utf-8") as f:
        tasks_from_file = json.load(f)

    tasks = tasks_from_file[FIRST_TASK : FIRST_TASK + MAX_TASKS_TO_PROCESS]
    print(
        f"Загружено {len(tasks_from_file)} задач из файла. Взято в обработку первые {len(tasks)}."
    )

except FileNotFoundError:
    print(
        f"Ошибка: Файл '{input_filename}' не найден. Убедитесь, что он находится в той же папке, что и скрипт."
    )
    sys.exit(1)
except json.JSONDecodeError:
    print(
        f"Ошибка: Не удалось прочитать JSON из файла '{input_filename}'. Проверьте его структуру."
    )
    sys.exit(1)


prompt_start = """
Твоя задача — извлечь именованные сущности из текста и структурировать их в определенном JSON-формате. Ты должен строго следовать приведенным ниже правилам и определениям сущностей. Тебе нужно выделить все сущности, даже если они встречаются несколько раз. Ты должен использовать свои представления о мире, формируя свой ответ.

### ОСНОВНЫЕ ПРАВИЛА РАЗМЕТКИ:
1.  **Точность извлечения:** Извлекай сущность в той же форме (падеж, число, регистр), в которой она стоит в тексте. Например, из «я читал книгу Льва Толстого» нужно извлечь именно `Льва Толстого`.
2.  **Полнота:** Если сущность состоит из нескольких слов, выделяй их все (например, `Лев Николаевич Толстой`). Если первая часть сущности указана в скобках (например "[Антонио Лючио] Вивальди.") - то выделяй все вместе
3.  **Без общих слов:** Не включай в разметку общие слова-категории ("роман", "картина", "король", "город"), если они не являются неотъемлемой частью имени (`Тихий океан` — правильно, `роман «Война и мир»` — неправильно).
4.  **Знаки препинания:**
    *   Включай в сущность кавычки, если они являются частью названия (`«Война и мир»`).
    *   **Не включай** в сущность окружающие знаки препинания: запятые, точки, скобки, если они не являются частью самого имени.
5.  **Контекст решает всё:** Внимательно анализируй весь текст, чтобы правильно определить тип сущности. Например, Наполеон как исторический деятель — `PERSON`, а Наполеон как персонаж романа «Война и мир» — `CHARACTER`.

### ОПРЕДЕЛЕНИЯ СУЩНОСТЕЙ И ИХ МЕТКИ (LABELS):

**1. `AUTHOR`**
*   **Описание:** Создатель произведения искусства. Писатель, художник, режиссер, композитор, а также музыкальные группы и творческие коллективы. Важно что бы человек упоминался именно как создатель произведения.
*   **Примеры:** `Александр Пушкин`, `Леонардо да Винчи`, `Альфред Хичкок`, `The Beatles`.
*   **Граничные случаи:** Если человек упоминается и как автор, и как историческая личность, приоритет отдается роли автора. Размечаем только имя, без титулов (`Уильям Шекспир`, а не `драматург Уильям Шекспир`).

**2. `PERSON`**
*   **Описание:** Реальный человек, который не является автором в данном контексте. Историческая личность, политик, спортсмен, ученый, инжинер.
*   **Примеры:** `Наполеон Бонапарт` (как полководец), `Юрий Гагарин`, `королева Виктория`.
*   **Граничные случаи:** `PERSON` — это всегда реальный человек.

**3. `CHARACTER`**
*   **Описание:** Вымышленный или мифологический персонаж. Герой книги, фильма, мифа, легенды, картины. Включая богов и антропоморфных животных.
*   **Примеры:** `Шерлок Холмс`, `Гамлет`, `Зевс`, `Чеширский Кот`, `Муму`.
*   **Граничные случаи:** Если реальный человек выступает как персонаж произведения (например, `Наполеон` в романе «Война и мир»), он размечается как `CHARACTER`.

**4. `WORK_OF_ART`**
*   **Описание:** Конкретное произведение искусства. Книга, картина, фильм, пьеса, скульптура, музыкальное произведение.
*   **Примеры:** `«Война и мир»`, `«Мона Лиза»`, `«Криминальное чтиво»`, `«Лебединое озеро»`.
*   **Граничные случаи:** Размечаем название целиком, включая кавычки, если они есть в тексте.

**5. `LOCATION`**
*   **Описание:** Географическое место, реальное или вымышленное. Город, страна, река, здание, планета, вымышленный мир.
*   **Примеры:** `Москва`, `река Нил`, `Лувр`, `Средиземье`, `Хогвартс`.
*   **Граничные случаи:** Если название локации включает общий термин, размечаем все вместе: `озеро Байкал`, `Тихий океан`.

### ЧЕГО ДЕЛАТЬ НЕ НУЖНО:
*   **Не нормализуй:** Не приводи имена к именительному падежу или начальной форме.
*   **Не додумывай:** Если в тексте написано `Толстой`, извлекай `Толстой`, а не `Лев Толстой`.
*   **Не разделяй:** Не разбивай одну сущность на несколько. `Лев Николаевич Толстой` — это одна сущность `AUTHOR`, а не три `PERSON`.
*   **Не выделяй вложенные сущности:** В "поездка в город-герой Москва" выдели только `Москва` как `LOCATION`.

### ИНСТРУКЦИИ ПО ФОРМАТИРОВАНИЮ:
1.  Верни единый JSON-объект.
2.  Этот объект должен содержать один ключ: "entities".
3.  Значением ключа "entities" должен быть СПИСОК JSON-объектов.
4.  **ВАЖНО:** Сущности в списке должны идти в том же порядке, в котором они появляются в исходном тексте.
5.  Каждый объект в списке должен содержать ДВА поля:
    *   `"text"`: точный фрагмент текста, который является сущностью.
    *   `"label"`: тип сущности (один из: `AUTHOR`, `PERSON`, `CHARACTER`, `WORK_OF_ART`, `LOCATION`).
6.  Если в тексте нет ни одной сущности, верни объект с пустым списком: `{"entities": []}`.

### ПРИМЕРЫ:
**Текст:** "В романе «Война и мир» Льва Толстого Наполеон показан как персонаж. Позже я слушал The Beatles в Лондоне."
**Результат:**
```json
{
  "entities": [
    {
      "text": "«Война и мир»",
      "label": "WORK_OF_ART"
    },
    {
      "text": "Льва Толстого",
      "label": "AUTHOR"
    },
    {
      "text": "Наполеон",
      "label": "CHARACTER"
    },
    {
      "text": "The Beatles",
      "label": "AUTHOR"
    },
    {
      "text": "Лондоне",
      "label": "LOCATION"
    }
  ]
}

**Текст:** "Ведущему: пожалуйста, чётко прочитайте слово «лилии», чтобы их не приняли за «линии».]\nВалерия Горде́ева пишет, что геральдические лилии на флаге Висба́дена напоминают И́КСы. На проекте герба Нефтеюга́нска был изображён несколько иной ИКС. Какое слово мы заменили словом «ИКС»?\n\nОТВЕТ:\nФонтан.\n\nКОММЕНТАРИЙ:\nВисбаден — бальнеологический курорт, на что указывает и элемент его названия «баден». На проекте герба v был изображён нефтяной фонтан."
**Результат:**
```json
{
  "entities": [
    {
      "text": "«Валерия Горде́ева»",
      "label": "AUTHOR"
    },
    {
      "text": "Висба́дена",
      "label": "LOCATION"
    },
    {
      "text": "Нефтеюга́нска",
      "label": "LOCATION"
    },
    {
      "text": "Висбаден",
      "label": "LOCATION"
    },
    {
      "text": "Нефтеюганска",
      "label": "LOCATION"
    }
  ]
}
---
ТЕКСТ ДЛЯ ОБРАБОТКИ:
"""


def process_task(args):
    task_id, task = args
    text_to_process = task["data"]["text"]

    try:
        response = client.chat.completions.create(
            model="o3",
            messages=[
                {
                    "role": "system",
                    "content": "Ты — ассистент по разметке данных в формате JSON.",
                },
                {"role": "user", "content": f"{prompt_start}{text_to_process}"},
            ],
            temperature=0.0,
            response_format={"type": "json_object"},
        )

        llm_output_str = response.choices[0].message.content

        parsed_json = json.loads(llm_output_str)
        entity_list = parsed_json.get("entities", [])

        results_for_ls = []
        search_from_index = 0

        for entity in entity_list:
            if not all(k in entity for k in ["text", "label"]):
                print(f"Задача {task_id}: Пропущена неполная сущность от LLM: {entity}")
                continue

            entity_text = entity["text"]
            entity_label = entity["label"]
            start_index = text_to_process.find(entity_text, search_from_index)

            if start_index == -1:
                print(
                    f"Задача {task_id}: Не удалось найти текст '{entity_text}' в исходном тексте. Пропускаем.",
                    file=sys.stderr,
                )
                continue

            end_index = start_index + len(entity_text)

            results_for_ls.append(
                {
                    "from_name": "label",
                    "to_name": "text",
                    "type": "labels",
                    "value": {
                        "start": start_index,
                        "end": end_index,
                        "text": entity_text,
                        "labels": [entity_label],
                    },
                }
            )
            search_from_index = end_index

        return {
            "data": {"text": text_to_process},
            "predictions": [{"model_version": "gpt-4.1", "result": results_for_ls}],
        }

    except json.JSONDecodeError as e:
        print(
            f"Ошибка декодирования JSON от LLM для задачи {task_id}: {e}",
            file=sys.stderr,
        )
        print(f"Полученная строка: {llm_output_str}", file=sys.stderr)
        return None
    except Exception as e:
        print(
            f"Неизвестная ошибка при обработке задачи {task_id}: {e}", file=sys.stderr
        )
        return None


tasks_for_label_studio = []
with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:

    future_to_task = executor.map(process_task, enumerate(tasks))

    for result in tqdm(future_to_task, total=len(tasks), desc="Обработка задач"):
        if result:
            tasks_for_label_studio.append(result)

output_filename = "predictions_for_label_studio_2.json"
with open(output_filename, "w", encoding="utf-8") as f:
    json.dump(tasks_for_label_studio, f, ensure_ascii=False, indent=2)


print(
    f"\nОбработка завершена. Предсказания для {len(tasks_for_label_studio)} задач сохранены в {output_filename}"
)
